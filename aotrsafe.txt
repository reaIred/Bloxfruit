repeat task.wait() until game:IsLoaded()
local Players = (cloneref(game:GetService('Players')))

repeat
    task.wait()
until Players.LocalPlayer



local player = Players.LocalPlayer

local success, result = pcall(function()
    return player:GetMouse()
end)

local mouse = success and result or nil

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Strawberry Cat Hub",
    SubTitle = "Attack on Titan:Revolution",
    TabWidth = 160,
    Size = UDim2.fromOffset(500, 350),
    Acrylic = false,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "" }),
    Ts = Window:AddTab({ Title = "Thunder Spears", Icon = "" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "" }),
    Raids = Window:AddTab({ Title = "Raids", Icon = "" }),
    Esp = Window:AddTab({ Title = "Titans Esp", Icon = "" }),
    AutoMission = Window:AddTab({ Title = "Auto Mission" }),
    Webhook = Window:AddTab({ Title = "Webhook", Icon = "" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "" }),
    Database = Window:AddTab({ Title = "Database", Icon = "" })
}

local allowedPlaceId = 13379208636

if game.PlaceId == allowedPlaceId then
    Tabs.Mainmenu = Window:AddTab({ Title = "Mainmenu", Icon = "" })
    Tabs.Mainmenu:AddToggle("AutoRollToggle", {
        Title = "Auto Roll",
        Default = false,
        Callback = function(state)
            ENABLED = state
        end
    })
end

Window:SelectTab(Tabs.Main)

-- Settings
local HttpService = (cloneref(game:GetService('HttpService')))
local RunService = game:GetService("RunService")
local VirtualInput = game:GetService("VirtualInputManager")
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local retryRemote = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("GET")
local TeleportService = game:GetService("TeleportService")

-- Auto Kill Titans
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local flySpeed = 250
local canHit = true
local isFlying = false
local moveMode = "Teleportation"
local notificationsEnabled = true
local notified = {}
local titanKillCount = 0
local autoRefill = false
local lastBladesEmpty = false
local lastSpearsEmpty = false
local startDelay = 5
local flyHeight = 250
local gasAmount = "N/A"
local bladesSets = "N/A"
local spearsAmount = "N/A"
local POST = nil


task.spawn(function()
    local success, result = pcall(function()
        return ReplicatedStorage:WaitForChild("Assets", 10):WaitForChild("Remotes", 10):WaitForChild("POST", 10)
    end)
    if success then
        POST = result
    end
end)

local activeNotifs = {}
function showKillNotification(count)
    if not notificationsEnabled then return end
    local gui = Instance.new("ScreenGui")
    gui.Name = "TitanNotif_" .. tick()
    gui.ResetOnSpawn = false
    gui.IgnoreGuiInset = true
    gui.Parent = CoreGui
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 190, 0, 75)
    frame.Position = UDim2.new(1, 20, 0, 10 + (#activeNotifs * 80))
    frame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(184, 164, 101)
    frame.Parent = gui
    local label = Instance.new("TextLabel", frame)
    label.Size = UDim2.new(0.65, 0, 1, 0)
    label.Position = UDim2.new(0, 5, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = "Succesfully\nHit:"
    label.TextColor3 = Color3.fromRGB(184, 164, 101)
    label.Font = Enum.Font.Fantasy
    label.TextScaled = true
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextYAlignment = Enum.TextYAlignment.Center
    local counter = Instance.new("TextLabel", frame)
    counter.Size = UDim2.new(0, 60, 0.5, 0)
    counter.Position = UDim2.new(1, -65, 0, 0)
    counter.BackgroundTransparency = 1
    counter.Text = tostring(count)
    counter.TextColor3 = Color3.fromRGB(255, 255, 255)
    counter.Font = Enum.Font.Fantasy
    counter.TextScaled = true
    counter.TextXAlignment = Enum.TextXAlignment.Right
    counter.TextYAlignment = Enum.TextYAlignment.Bottom
    local big = Instance.new("TextLabel", frame)
    big.Size = UDim2.new(0.6, 0, 0.5, 0)
    big.Position = UDim2.new(1, -115, 0.5, 0)
    big.BackgroundTransparency = 1
    big.Text = "Titans"
    big.TextColor3 = Color3.fromRGB(255, 255, 255)
    big.Font = Enum.Font.Fantasy
    big.TextScaled = true
    big.TextXAlignment = Enum.TextXAlignment.Right
    big.TextYAlignment = Enum.TextYAlignment.Top
    table.insert(activeNotifs, gui)
    TweenService:Create(frame, TweenInfo.new(0.35, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
        Position = UDim2.new(1, -210, 0, 10 + ((#activeNotifs - 1) * 80))
    }):Play()
    task.delay(5, function()
        TweenService:Create(frame, TweenInfo.new(0.35, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {
            Position = UDim2.new(1, 20, frame.Position.Y.Scale, frame.Position.Y.Offset),
            BackgroundTransparency = 1
        }):Play()
        task.wait(0.4)
        gui:Destroy()
        for i, v in ipairs(activeNotifs) do
            if v == gui then
                table.remove(activeNotifs, i)
                break
            end
        end
        for i, notif in ipairs(activeNotifs) do
            local f = notif:FindFirstChildWhichIsA("Frame")
            if f then
                TweenService:Create(f, TweenInfo.new(0.3), {
                    Position = UDim2.new(1, -210, 0, 10 + ((i - 1) * 80))
                }):Play()
            end
        end
    end)
end

local function getClosestValidNape()
    local titansFolder = workspace:FindFirstChild("Titans")
    if not titansFolder then
        if notificationsEnabled then
            Fluent:Notify({
                Title = "Auto Kill Titans",
                Content = "Titans folder not found!",
                Duration = 3
            })
        end
        return nil
    end
    local priorityList = {
        "Attack_Titan",
        "Female_Titan",
        "Armored_Titan"
    }
    for _, titanName in ipairs(priorityList) do
        local titan = titansFolder:FindFirstChild(titanName)
        if titan and titan:FindFirstChild("Humanoid") and titan.Humanoid.Health > 0 then
            local hitbox = titan:FindFirstChild("Hitboxes") and titan.Hitboxes:FindFirstChild("Hit")
            local nape = hitbox and hitbox:FindFirstChild("Nape")
            if nape and nape:IsA("BasePart") and nape:IsDescendantOf(workspace) then
                return nape
            end
        end
    end
    local closest, dist = nil, math.huge
    for _, titan in ipairs(titansFolder:GetChildren()) do
        if table.find(priorityList, titan.Name) then
            continue
        end
        local hitboxes = titan:FindFirstChild("Hitboxes")
        if hitboxes then
            local hit = hitboxes:FindFirstChild("Hit")
            if hit then
                local nape = hit:FindFirstChild("Nape")
                local hum = titan:FindFirstChildWhichIsA("Humanoid")
                if nape and nape:IsA("BasePart") and nape:IsDescendantOf(workspace) and hum and hum.Health > 0 then
                    local d = (hrp.Position - nape.Position).Magnitude
                    if d < dist then
                        closest = nape
                        dist = d
                    end
                end
            end
        end
    end
    if not closest and notificationsEnabled then
        Fluent:Notify({
            Title = "Auto Kill Titans",
            Content = "No valid nape found!",
            Duration = 3
        })
    end
    return closest
end

local function getLegitDamage(nape)
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return 0, 0.25 end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local velocity = hrp.AssemblyLinearVelocity.Magnitude
    local dist = (hrp.Position - nape.Position).Magnitude
    local baseDmg = math.floor(velocity * 2 + dist / 4)
    local randomFactor = math.random(95, 105) / 100
    local dmg = baseDmg * randomFactor
    dmg = math.clamp(dmg, 200, 300)
    local accuracy = math.random(20, 30) / 100
    return dmg, accuracy
end

local titanHitCooldown = {}
local killConnectionGlobal -- moved outside to retain

function killFromAbove()
	repeat task.wait() until POST
	task.wait(startDelay)

	if killConnectionGlobal then
		killConnectionGlobal:Disconnect()
	end

	killConnectionGlobal = RunService.Heartbeat:Connect(function()
		if not isFlying or not character or not hrp or character.Humanoid.Health <= 0 then
			return
		end

		local nape = getClosestValidNape()
		if not nape or not nape:IsDescendantOf(workspace) then return end

		local titanModel = nape:FindFirstAncestorWhichIsA("Model")
		local hum = titanModel and titanModel:FindFirstChildWhichIsA("Humanoid")
		if not hum or hum.Health <= 0 then return end

		local targetPos = nape.Position + Vector3.new(math.random(-5, 5), flyHeight, math.random(-5, 5))
		if moveMode == "Gliding" then
			hrp.AssemblyLinearVelocity = (targetPos - hrp.Position).Unit * flySpeed
		else
			hrp.CFrame = CFrame.new(targetPos)
		end

		local dist = (hrp.Position - nape.Position).Magnitude
		local id = nape:GetFullName()

		if dist <= 1500 and (not titanHitCooldown[id] or tick() - titanHitCooldown[id] >= 1.5) then
			titanHitCooldown[id] = tick()

			local dmg, accuracy = getLegitDamage(nape)
			local success = pcall(function()
            POST:FireServer("Attacks", "Slash", true)
            task.wait(0.08)
				POST:FireServer("Hitboxes", "Register", nape, dmg, accuracy)
			end)

			if success then
				titanKillCount += 1
				showKillNotification(titanKillCount)
			end
		end
	end)
end

Tabs.Main:AddToggle("AutoKillTitans", {
    Title = "Auto Kill Titans",
    Description = "Dont Finish the mission under 17 sec",
    Default = false,
    Callback = function(state)
        isFlying = state
        if state then
            Fluent:Notify({
                Title = "Warning",
                Content = "Use sparingly to avoid detection.",
                Duration = 5
            })
            task.spawn(killFromAbove)
        end
    end
})

Tabs.Main:AddDropdown("MoveMode", {
    Title = "Movement Mode",
    Values = { "Teleportation", "Gliding" },
    Default = 1,
    Callback = function(option)
        moveMode = option
    end
})

Tabs.Main:AddSlider("StartDelaySlider", {
    Title = "Farm Delay",
    Description = "MINIMUM 20 SECONDS For Thunder Spears / MINIMUM 10 SECONDS For Blades",
    Default = 5,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Callback = function(value)
        startDelay = value
    end
})

Tabs.Main:AddSlider("FlySpeedSlider", {
    Title = "Gliding Speed",
    Default = 300,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Callback = function(value)
        flySpeed = value
    end
})

Tabs.Main:AddSlider("FlyHeightSlider", {
    Title = "Float Height",
    Default = 250,
    Min = 50,
    Max = 300,
    Rounding = 0,
    Callback = function(value)
        flyHeight = value
    end
})

Tabs.Misc:AddToggle("ToggleNotifications", {
    Title = "Notifications",
    Default = false,
    Callback = function(value)
        notificationsEnabled = value
    end
})

-- Auto Thunder Spears
local gui = player:WaitForChild("PlayerGui")
local GET = ReplicatedStorage.Assets.Remotes.GET
local isHovering = false
local hoverPos = nil
local autoTSRunning = false
local killMode = "Safe"
local tsDelay = 1.5

local function getCurrentSpearSlot()
    local lbl = gui:FindFirstChild("Interface") and gui.Interface:FindFirstChild("HUD") and gui.Interface.HUD:FindFirstChild("Main") and gui.Interface.HUD.Main:FindFirstChild("Top") and gui.Interface.HUD.Main.Top:FindFirstChild("Spears") and gui.Interface.HUD.Main.Top.Spears:FindFirstChild("Spears")
    if lbl and lbl:IsA("TextLabel") then
        local current = tonumber(lbl.Text:match("^(%d+)") or "0")
        return tostring(current), current > 0
    end
    return "0", false
end

local function getClosestNapes(limit)
    local priority = { "Female_Titan", "Attack_Titan", "Armored_Titan" }
    local selected = {}
    for _, titan in ipairs(workspace.Titans:GetChildren()) do
        if table.find(priority, titan.Name) then
            local hum = titan:FindFirstChild("Humanoid")
            local hitbox = titan:FindFirstChild("Hitboxes") and titan.Hitboxes:FindFirstChild("Hit")
            local nape = hitbox and hitbox:FindFirstChild("Nape")
            if hum and hum.Health > 0 and nape and nape:IsA("BasePart") then
                table.insert(selected, { part = nape, dist = (hrp.Position - nape.Position).Magnitude })
            end
        end
    end
    if #selected > 0 then
        table.sort(selected, function(a, b) return a.dist < b.dist end)
        local out = {}
        for i = 1, math.min(limit, #selected) do
            table.insert(out, selected[i].part)
        end
        return out
    end
    for _, titan in ipairs(workspace.Titans:GetChildren()) do
        if not table.find(priority, titan.Name) then
            local hum = titan:FindFirstChild("Humanoid")
            local hitbox = titan:FindFirstChild("Hitboxes") and titan.Hitboxes:FindFirstChild("Hit")
            local nape = hitbox and hitbox:FindFirstChild("Nape")
            if hum and hum.Health > 0 and nape and nape:IsA("BasePart") then
                table.insert(selected, { part = nape, dist = (hrp.Position - nape.Position).Magnitude })
            end
        end
    end
    table.sort(selected, function(a, b) return a.dist < b.dist end)
    local out = {}
    for i = 1, math.min(limit, #selected) do
        table.insert(out, selected[i].part)
    end
    return out
end

RunService.Heartbeat:Connect(function()
    if isHovering and hoverPos and character and hrp and hrp.Parent == character and character.Humanoid.Health > 0 then
        hrp.Velocity = Vector3.zero
        hrp.CFrame = CFrame.new(hoverPos)
    end
end)

local function autoTS_KillLoop()
    local firstRun = true
    while autoTSRunning do
        task.wait(tsDelay)
        if not character or not character:FindFirstChild("Humanoid") or character.Humanoid.Health <= 0 then
            continue
        end
        pcall(function()
            if workspace:FindFirstChild("Debris") and workspace.Debris:FindFirstChild("Roar") then
                repeat task.wait(0.1) until not workspace.Debris:FindFirstChild("Roar")
            end
            local slot, hasAmmo = getCurrentSpearSlot()
            if hasAmmo then
                local killCount = (killMode == "Risk") and math.random(10, 15) or math.random(3, 5) -- Reduced for safety
                local napes = getClosestNapes(killCount)
                if #napes > 0 then
                    local target = napes[1]
                    hoverPos = target.Position + Vector3.new(0, flyHeight, 0)
                    if (hrp.Position - hoverPos).Magnitude > 150 then
                        character:PivotTo(CFrame.new(hoverPos))
                    else
                        hrp.CFrame = CFrame.new(hoverPos)
                    end
                    isHovering = true
                    if firstRun then
                        task.wait(startDelay)
                        firstRun = false
                    end
                    GET:InvokeServer("Spears", "S_Fire", slot)
                    for _, nape in ipairs(napes) do
                        if nape and nape.Position then
                            POST:FireServer("Spears", "S_Explode", nape.Position, 0.501303055920385, 450.20495501920485)
                        end
                    end
                    task.wait(math.random(2, 3)) -- Added delay
                else
                    isHovering = false
                    hoverPos = nil
                end
            else
                isHovering = false
                hoverPos = nil
            end
        end)
    end
end

local function findRefill()
    local reloads = workspace:FindFirstChild("Unclimbable") and workspace.Unclimbable:FindFirstChild("Reloads")
    if reloads then
        for _, obj in ipairs(reloads:GetChildren()) do
            if obj:FindFirstChild("Refill") then
                return obj.Refill
            end
        end
    end
    return nil
end

local function isBladesZero()
    local sets = gui:FindFirstChild("Interface", true) and gui.Interface.HUD.Main.Top.Blades:FindFirstChild("Sets", true)
    if sets and sets:IsA("TextLabel") then
        return tonumber(sets.Text:match("^(%d+)") or "0") == 0
    end
    return false
end

local function isSpearsZero()
    local lbl = gui:FindFirstChild("Interface", true) and gui.Interface.HUD.Main.Top.Spears:FindFirstChild("Spears", true)
    if lbl and lbl:IsA("TextLabel") then
        return tonumber(lbl.Text:match("^(%d+)") or "0") == 0
    end
    return false
end

local canRefill = true
task.spawn(function()
    repeat task.wait() until POST
    while true do
        task.wait(0.3)
        if autoRefill and canRefill then
            local refill = findRefill()
            if not refill then continue end
            local bladesEmptyNow = isBladesZero()
            local spearsEmptyNow = isSpearsZero()
            local didPost = false
            if bladesEmptyNow and not lastBladesEmpty then
                POST:FireServer("Attacks", "Reload", refill)
                didPost = true
            end
            if spearsEmptyNow and not lastSpearsEmpty then
                POST:FireServer("Attacks", "Reload", refill)
                didPost = true
            end
            if didPost then
                canRefill = false
                task.delay(1, function() canRefill = true end)
            end
            lastBladesEmpty = bladesEmptyNow
            lastSpearsEmpty = spearsEmptyNow
        end
    end
end)

local function handleAutoTS_Toggle(state)
    autoTSRunning = state
    if state then
        Fluent:Notify({
            Title = "Warning",
            Content = "Auto Thunder Spears is risky. Use cautiously.",
            Duration = 5
        })
        task.spawn(autoTS_KillLoop)
    end
end

Tabs.Ts:AddToggle("AutoTS_Free", {
    Title = "Auto Thunder Spears",
    Default = false,
    Callback = handleAutoTS_Toggle
})

Tabs.Ts:AddDropdown("KillModeDropdown", {
    Title = "Kill Mode",
    Values = { "Safe", "Risk" },
    Multi = false,
    Default = "Safe",
    Callback = function(value)
        killMode = value
    end
})

Tabs.Ts:AddSlider("TSDelaySlider", {
    Title = "Thunder Spears Delay",
    Default = 1.5,
    Min = 0.9,
    Max = 4,
    Rounding = 1,
    Callback = function(value)
        tsDelay = value
        if value < 1 and notificationsEnabled then
            Fluent:Notify({
                Title = "Auto Thunder Spears",
                Content = "Delay < 1s may increase detection risk.",
                Duration = 3
            })
        end
    end
})

-- Auto Mission
getgenv().selectedMap = "Shiganshina"
getgenv().selectedDifficulty = "Hard"
getgenv().selectedObjective = "Skirmish"
local selectedModifiers = {}
local mapOptions = { "Shiganshina", "Trost", "Outskirts", "Giant Forest", "Utgard", "Loading Docks", "Stohess" }
Tabs.AutoMission:AddDropdown("MapDropdown", {
    Title = "Select Map",
    Values = mapOptions,
    Multi = false,
    Default = "Shiganshina",
    Callback = function(value)
        getgenv().selectedMap = value
    end
})

local difficultyOptions = { "Easy", "Normal", "Hard", "Severe", "Aberrant" }
Tabs.AutoMission:AddDropdown("DifficultyDropdown", {
    Title = "Select Difficulty",
    Values = difficultyOptions,
    Multi = false,
    Default = "Hard",
    Callback = function(value)
        getgenv().selectedDifficulty = value
    end
})

local objectiveOptions = { "Skirmish", "Breach", "Protect", "Escort", "Defend", "Stall", "Guard", "Random" }
Tabs.AutoMission:AddDropdown("ObjectiveDropdown", {
    Title = "Select Objective",
    Values = objectiveOptions,
    Multi = false,
    Default = "Skirmish",
    Callback = function(value)
        getgenv().selectedObjective = value
    end
})

local modifierOptions = { "No Perks", "No Skills", "No Talents", "Nightmare", "Oddball", "Injury Prone", "Chronic Injuries", "Fog", "Glass Cannon", "Time Trial", "Boring", "Simple" }
Tabs.AutoMission:AddDropdown("ModifierDropdown", {
    Title = "Modifiers",
    Description = "Select mission modifiers",
    Values = modifierOptions,
    Multi = true,
    Default = {},
    Callback = function(selected)
        for _, mod in ipairs(modifierOptions) do
            if mod ~= "None" then selectedModifiers[mod] = false end
        end
        if table.find(selected, "None") then
            selectedModifiers = {}
            if notificationsEnabled then
                Fluent:Notify({
                    Title = "Modifiers Updated",
                    Content = "Selected: None",
                    Duration = 3
                })
            end
            return
        end
        for _, mod in ipairs(selected) do
            selectedModifiers[mod] = true
        end
        if notificationsEnabled then
            Fluent:Notify({
                Title = "Modifiers Updated",
                Content = "Selected: " .. table.concat(selected, ", "),
                Duration = 3
            })
        end
    end
})

Tabs.AutoMission:AddButton({
    Title = "Start Create Mission (Lobby)",
    Callback = function()
        if not ReplicatedStorage:FindFirstChild("Missions") then return end
        GET:InvokeServer("Missions", "Open")
        task.wait(1.5)
        local activeModifiers = {}
        for _, mod in ipairs(modifierOptions) do
            if selectedModifiers[mod] then table.insert(activeModifiers, mod) end
        end
        local mapData = {
            Name = getgenv().selectedMap,
            Difficulty = getgenv().selectedDifficulty,
            Type = "Missions",
            Objective = getgenv().selectedObjective
        }
        POST:FireServer("S_Missions", "Create", mapData)
        local isLeader = false
        local timeout = 10
        local elapsed = 0
        local mission = nil
        while elapsed < timeout do
            for _, m in pairs(ReplicatedStorage.Missions:GetChildren()) do
                local leader = m:FindFirstChild("Leader")
                if leader and leader.Value == player.Name then
                    mission = m
                    isLeader = true
                    break
                end
            end
            if isLeader then break end
            task.wait(1)
            elapsed = elapsed + 1
        end
        if isLeader and mission then
            for _, mod in ipairs(activeModifiers) do
                GET:InvokeServer("S_Missions", "Modify", mod)
                task.wait(0.1)
            end
            task.wait(1)
            POST:FireServer("S_Missions", "Start")
        end
    end
})

local autoCompleteMissionEnabled = false
local autoReloadRunning = false
local autoReloadThread = nil
local BladeBar = nil

do
    local success, err = pcall(function()
        local playerGui = player:FindFirstChild("PlayerGui")
        local interface = playerGui and playerGui:FindFirstChild("Interface")
        local hud = interface and interface:FindFirstChild("HUD")
        local main = hud and hud:FindFirstChild("Main")
        local top = main and main:FindFirstChild("Top")
        local blades = top and top:FindFirstChild("Blades")
        local inner = blades and blades:FindFirstChild("Inner")
        local bar = inner and inner:FindFirstChild("Bar")
        BladeBar = bar and bar:FindFirstChild("Gradient")
    end)
end

local function countAliveTitans()
    local titansFolder = workspace:FindFirstChild("Titans")
    [span_9](start_span)if not titansFolder then return 0 end[span_9](end_span)
    local count = 0
    [span_1](start_span)for _, titan in ipairs(titansFolder:GetChildren()) do[span_1](end_span)
        [span_2](start_span)local hum = titan:FindFirstChild("Humanoid")[span_2](end_span)
        [span_3](start_span)if hum and hum.Health > 0 then count = count + 1 end[span_3](end_span)
    end
    return count
end

local function enableAutoFeatures()
    if not isFlying then
        isFlying = true
        moveMode = "Gliding"
        task.spawn(killFromAbove)
    end
    autoRefill = true
    if BladeBar then
        autoReloadRunning = true
        if not autoReloadThread then
            autoReloadThread = task.spawn(function()
                while autoReloadRunning do
                    if BladeBar.Offset == Vector2.new(-0.15, 0) then
                        pcall(function()
                            GET:InvokeServer("Blades", "Reload")
                        end)
                    end
                    task.wait(0.3)
                end
            end)
        end
    end
end

local function disableAutoFeatures()
    isFlying = false
    autoRefill = false
    autoReloadRunning = false
    if autoReloadThread then autoReloadThread = nil end
end

local function autoCompleteMissionLoop()
    while autoCompleteMissionEnabled do
        local aliveTitans = countAliveTitans()
        if aliveTitans == 0 then
            if notificationsEnabled then
                Fluent:Notify({
                    Title = "Auto Complete Mission",
                    Content = "All titans eliminated!",
                    Duration = 3
                })
            end
            disableAutoFeatures()
            break
        end
        enableAutoFeatures()
        task.wait(math.random(120, 180) / 100) -- Random delay
    end
end

Tabs.AutoMission:AddToggle("AutoCompleteMission", {
    Title = "Auto Complete Mission",
    Default = false,
    Callback = function(state)
        autoCompleteMissionEnabled = state
        if state then
            Fluent:Notify({
                Title = "Warning",
                Content = "Auto Mission may attract attention. Use wisely.",
                Duration = 5
            })
            task.spawn(autoCompleteMissionLoop)
        else
            disableAutoFeatures()
        end
    end
})

-- Auto Reload
Tabs.Main:AddToggle("AutoReload", {
    Title = "Auto Reload Blades",
    Default = false,
    Callback = function(Value)
        if not BladeBar then return end
        if Value then
            autoReloadRunning = true
            autoReloadThread = task.spawn(function()
                while autoReloadRunning do
                    if BladeBar.Offset == Vector2.new(-0.15, 0) then
                        pcall(function()
                            GET:InvokeServer("Blades", "Reload")
                        end)
                    end
                    task.wait(0.3)
                end
            end)
        else
            autoReloadRunning = false
        end
    end
})

Tabs.Main:AddToggle("AutoRefillToggle", {
    Title = "Auto Refill",
    Default = false,
    Callback = function(state)
        autoRefill = state
    end
})

-- Auto Retry
local VirtualInputManager = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")
local autoRetryEnabled = false

local function updateNavigation(guiObject)
    if guiObject then GuiService.SelectedObject = guiObject end
end

local function pressRetryKey(retryBtn)
    updateNavigation(retryBtn)
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
    task.wait(0.01)
    updateNavigation(nil)
end

local function shouldClickRetry()
    local interface = player:FindFirstChild("PlayerGui") and player.PlayerGui:FindFirstChild("Interface")
    local rewards = interface and interface:FindFirstChild("Rewards")
    local rewardsMain = rewards and rewards:FindFirstChild("Main")
    local info = rewardsMain and rewardsMain:FindFirstChild("Info")
    local infoMain = info and info:FindFirstChild("Main")
    local buttons = infoMain and infoMain:FindFirstChild("Buttons")
    local retryBtn = buttons and buttons:FindFirstChild("Retry")
    if retryBtn and rewards and rewards.Visible and rewardsMain and rewardsMain.Visible and retryBtn.Visible and retryBtn.AbsoluteSize.Magnitude > 10 then
        return retryBtn
    end
    return nil
end

task.spawn(function()
    while true do
        if autoRetryEnabled then
            local retryBtn = shouldClickRetry()
            if retryBtn then
                task.wait(1)
                if shouldClickRetry() then
                    pressRetryKey(retryBtn)
                    task.wait(3.5)
                end
            end
        end
        task.wait(0.5)
    end
end)

Tabs.Main:AddToggle("AutoRetryToggle", {
    Title = "Auto Retry",
    Default = false,
    Callback = function(state)
        autoRetryEnabled = state
    end
})

-- Auto Escape
local escapeRunning = false
local escapeThread = nil
local cleanGUIThread = nil
local lastEscapeButton = nil

Tabs.Main:AddToggle("Escape", {
    Title = "Auto Escape",
    Default = false,
    Callback = function(Value)
        escapeRunning = Value
        if escapeRunning then
            escapeThread = task.spawn(function()
                while escapeRunning do
                    local interface = gui:FindFirstChild("Interface")
                    local buttons = interface and interface:FindFirstChild("Buttons")
                    if buttons then
                        local currentButtons = buttons:GetChildren()
                        if #currentButtons > 0 then
                            local newestButton = currentButtons[1]
                            if newestButton ~= lastEscapeButton then
                                lastEscapeButton = newestButton
                                POST:FireServer("Attacks", "Slash_Escape")
                            end
                        else
                            lastEscapeButton = nil
                        end
                    else
                        lastEscapeButton = nil
                    end
                    task.wait(0.1)
                end
            end)
            cleanGUIThread = task.spawn(function()
                while escapeRunning do
                    local interface = gui:FindFirstChild("Interface")
                    local buttons = interface and interface:FindFirstChild("Buttons")
                    if buttons then
                        for _, btn in pairs(buttons:GetChildren()) do
                            btn:Destroy()
                        end
                    end
                    task.wait(0.1)
                end
            end)
        else
            escapeRunning = false
            lastEscapeButton = nil
        end
    end
})

-- Delete Map
local hiddenFolder = ReplicatedStorage:FindFirstChild("aristo_deletemap") or Instance.new("Folder")
hiddenFolder.Name = "aristo_deletemap"
hiddenFolder.Parent = ReplicatedStorage

Tabs.Misc:AddToggle("del", {
    Title = "Delete Map",
    Default = false,
    Callback = function(state)
        if state then
            local climbable = workspace:FindFirstChild("Climbable")
            if climbable then
                local fakeClimbable = Instance.new("Folder")
                fakeClimbable.Name = "Climbable"
                fakeClimbable.Parent = workspace
                climbable.Parent = hiddenFolder
            end
            local unclimbable = workspace:FindFirstChild("Unclimbable")
            if unclimbable then
                for _, child in ipairs(unclimbable:GetChildren()) do
                    local name = child.Name
                    local shouldKeep = (name == "Reloads" or name == "Objective" or name == "Cutscene")
                    if not shouldKeep and not child:IsA("Terrain") and not (child:IsA("BasePart") and child.Size.Magnitude > 100) then
                        pcall(function() child.Parent = hiddenFolder end)
                    end
                end
                local objective = unclimbable:FindFirstChild("Objective")
                if objective then
                    local guard = objective:FindFirstChild("Guard")
                    if guard then
                        local collider = guard:FindFirstChild("Collider")
                        if collider and collider:IsA("BasePart") then
                            collider.CanTouch = false
                            collider.CanCollide = false
                            collider.Transparency = 1
                        end
                    end
                end
            end
        else
            for _, item in ipairs(hiddenFolder:GetChildren()) do
                if item.Name == "Climbable" then
                    item.Parent = workspace
                elseif item:IsA("Instance") then
                    item.Parent = workspace:FindFirstChild("Unclimbable") or workspace
                end
            end
        end
    end
})

local delaySeconds = 180
local toggleActive = false

Tabs.Misc:AddToggle("ForceRetryToggle", {
    Title = "Fail Safe",
    Default = false,
    Callback = function(state)
        toggleActive = state
        if state then
            task.delay(delaySeconds, function()
                if toggleActive then
                    pcall(function() retryRemote:InvokeServer("Functions", "Retry", "Add") end)
                end
            end)
        end
    end
})

-- Anti Injuries
Tabs.Misc:AddToggle("injjj", {
    Title = "Anti Injuries",
    Default = false,
    Callback = function(state)
        if state then
            local char = player.Character or player.CharacterAdded:Wait()
            local injuriesFolder = char:WaitForChild("Injuries", 10)
            if not injuriesFolder then return end
            for _, injury in pairs(injuriesFolder:GetChildren()) do
                injury:Destroy()
            end
            getgenv().AntiInjuryConnection = injuriesFolder.ChildAdded:Connect(function(child)
                task.wait()
                child:Destroy()
            end)
        else
            if getgenv().AntiInjuryConnection then
                getgenv().AntiInjuryConnection:Disconnect()
                getgenv().AntiInjuryConnection = nil
            end
        end
    end
})

-- Remove Dmg Text
local interface = player:WaitForChild("PlayerGui"):WaitForChild("Interface")
local damageConnection

Tabs.Misc:AddToggle("dmg", {
    Title = "Remove Dmg Text",
    Default = false,
    Callback = function(state)
        if state then
            for _, obj in pairs(interface:GetDescendants()) do
                if obj:IsA("TextLabel") and obj.Name == "Number" then
                    obj.Visible = false
                end
            end
            damageConnection = interface.DescendantAdded:Connect(function(obj)
                if obj:IsA("TextLabel") and obj.Name == "Number" then
                    obj.Visible = false
                end
            end)
        else
            if damageConnection then
                damageConnection:Disconnect()
                damageConnection = nil
            end
        end
    end
})

-- Main + Lobby
local lobbyPlaceId = 14916516914
local mainMenuPlaceId = 13379208636

Tabs.Misc:AddButton({
    Title = "Return to Lobby",
    Callback = function()
        TeleportService:Teleport(lobbyPlaceId, player)
    end
})

Tabs.Misc:AddButton({
    Title = "Return to Main Menu",
    Callback = function()
        TeleportService:Teleport(mainMenuPlaceId, player)
    end
})

Tabs.Misc:AddButton({
    Title = "Force Retry",
    Callback = function()
        pcall(function() retryRemote:InvokeServer("Functions", "Retry", "Add") end)
    end
})

-- Nape Extend
local newSize = Vector3.new(50, 50, 50) -- Reduced size for safety
local originalSizes = {}
local connection

local function resizeNapes()
    for _, v in pairs(workspace:GetDescendants()) do
        if v:IsA("BasePart") and v.Name == "Nape" then
            if not originalSizes[v] then originalSizes[v] = v.Size end
            v.Size = newSize
            v.CFrame = v.CFrame
        end
    end
end

Tabs.Main:AddToggle("nape", {
    Title = "Nape Extend",
    Default = false,
    Callback = function(state)
        if state then
            Fluent:Notify({
                Title = "Warning",
                Content = "Nape Extend is highly detectable. Use with caution.",
                Duration = 5
            })
            resizeNapes()
            connection = workspace.DescendantAdded:Connect(function(desc)
                if desc:IsA("BasePart") and desc.Name == "Nape" then
                    task.wait(0.1)
                    if not originalSizes[desc] then originalSizes[desc] = desc.Size end
                    desc.Size = newSize
                    desc.CFrame = desc.CFrame
                end
            end)
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
            for nape, originalSize in pairs(originalSizes) do
                if nape and nape.Parent then nape.Size = originalSize end
            end
            originalSizes = {}
        end
    end
})

-- Auto Roll
local VIM = game:GetService("VirtualInputManager")
local Gui = player:WaitForChild("PlayerGui")
local CLICK_DELAY = 0.2
local WAIT_DELAY = 1
local ENABLED = false

local function canClick(btn)
    return btn and btn.Visible and btn.AbsoluteSize.Magnitude > 10
end

local function isActuallyVisible(obj)
    if not obj then return false end
    local current = obj
    while current and current ~= Gui do
        local success, result = pcall(function() return current.Visible end)
        if success and not result then return false end
        current = current.Parent
    end
    return obj.AbsoluteSize.Magnitude > 10
end

local function clickButton(btn)
    if not btn then return false end
    local pos = btn.AbsolutePosition
    local size = btn.AbsoluteSize
    local inset = GuiService:GetGuiInset()
    local x = pos.X + size.X / 2
    local y = pos.Y + size.Y / 2 + inset.Y
    VIM:SendMouseMoveEvent(x, y, game)
    task.wait(0.05)
    VIM:SendMouseButtonEvent(x, y, 0, true, game, 0)
    task.wait(0.05)
    VIM:SendMouseButtonEvent(x, y, 0, false, game, 0)
    return true
end

local function findButton(parent, buttonName)
    if not parent then return nil end
    local function searchRecursive(obj)
        if obj.Name == buttonName and obj:IsA("GuiButton") then return obj end
        for _, child in pairs(obj:GetChildren()) do
            local result = searchRecursive(child)
            if result then return result end
        end
        return nil
    end
    return searchRecursive(parent)
end

local function findButtonByText(parent, text)
    if not parent then return nil end
    local function searchRecursive(obj)
        if obj:IsA("GuiButton") or obj:IsA("TextButton") then
            local hasText = obj:FindFirstChild("Text") or obj.Text
            if hasText and string.find(string.lower(tostring(hasText)), string.lower(text)) then
                return obj
            end
        end
        for _, child in pairs(obj:GetChildren()) do
            local result = searchRecursive(child)
            if result then return result end
        end
        return nil
    end
    return searchRecursive(parent)
end

task.spawn(function()
    local interface = Gui:WaitForChild("Interface", 10)
    if not interface then return end
    local rollButton = nil
    local searchPaths = { "Customisation.Family.Buttons_2.Roll", "Roll", "RollButton" }
    for _, path in pairs(searchPaths) do
        local pathParts = string.split(path, ".")
        local current = interface
        for _, part in pairs(pathParts) do
            if current then current = current:FindFirstChild(part) end
        end
        if current and current:IsA("GuiButton") then
            rollButton = current
            break
        end
    end
    if not rollButton then rollButton = findButton(interface, "Roll") end
    if not rollButton then rollButton = findButtonByText(interface, "roll") end
    if not rollButton then return end
    while true do
        if ENABLED then
            if canClick(rollButton) and isActuallyVisible(rollButton) then
                clickButton(rollButton)
                task.wait(CLICK_DELAY + math.random(0.1, 0.3)) -- Random delay
            else
                task.wait(WAIT_DELAY)
            end
        else
            task.wait(1)
        end
    end
end)

-- ESP
local ESPEnabled = false
local ESPColor = Color3.fromRGB(100, 100, 100) -- Less conspicuous
local ESPSize = Vector3.new(10, 10, 10) -- Smaller size
-- [[ --- BỔ SUNG KHAI BÁO BIẾN CHO TITAN ESP --- ]]

local TitanESPColor = Color3.fromRGB(255, 0, 0) -- Màu đỏ cho Titan
local TitanBoxSize = Vector3.new(20, 40, 20) -- Kích thước khung bao quanh
local TitanESP = {} -- Bảng để lưu trữ các ScreenGui ESP

-- [[ --- HÀM TẠO VÀ CẬP NHẬT TITAN ESP --- ]]

local function worldToScreen(position)
    local screenPoint, onScreen = workspace.CurrentCamera:WorldToScreenPoint(position)
    return Vector2.new(screenPoint.X, screenPoint.Y), onScreen
end

local function createTitanLabel(titan)
    local guidName = titan:GetFullName()
    if TitanESP[guidName] then return end

    local gui = Instance.new("ScreenGui")
    gui.Name = "TitanESP_" .. guidName
    gui.Parent = CoreGui
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 150, 0, 60)
    frame.BackgroundTransparency = 0.8
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BorderSizePixel = 0
    frame.Parent = gui

    local titanName = Instance.new("TextLabel", frame)
    titanName.Size = UDim2.new(1, 0, 0.3, 0)
    titanName.Position = UDim2.new(0, 0, 0, 0)
    titanName.BackgroundTransparency = 1
    titanName.TextColor3 = TitanESPColor
    titanName.Font = Enum.Font.SourceSansBold
    titanName.TextScaled = true
    titanName.TextXAlignment = Enum.TextXAlignment.Left
    titanName.Text = titan.Name

    local distance = Instance.new("TextLabel", frame)
    distance.Name = "Distance"
    distance.Size = UDim2.new(1, 0, 0.3, 0)
    distance.Position = UDim2.new(0, 0, 0.3, 0)
    distance.BackgroundTransparency = 1
    distance.TextColor3 = Color3.fromRGB(255, 255, 255)
    distance.Font = Enum.Font.SourceSans
    distance.TextScaled = true
    distance.TextXAlignment = Enum.TextXAlignment.Left
    distance.Text = "Dist: N/A"

    local health = Instance.new("TextLabel", frame)
    health.Name = "Health"
    health.Size = UDim2.new(1, 0, 0.4, 0)
    health.Position = UDim2.new(0, 0, 0.6, 0)
    health.BackgroundTransparency = 1
    health.TextColor3 = Color3.fromRGB(0, 255, 0)
    health.Font = Enum.Font.SourceSansBold
    health.TextScaled = true
    health.TextXAlignment = Enum.TextXAlignment.Left
    health.Text = "HP: N/A"

    TitanESP[guidName] = { gui = gui, frame = frame, box = nil }
end

local function createTitanBox(titan)
    if not titan:FindFirstChild("TitanBoxESP") then
        local esp = Instance.new("BoxHandleAdornment")
        esp.Name = "TitanBoxESP"
        esp.Adornee = titan:FindFirstChild("HumanoidRootPart") or titan:FindFirstChild("HRP") or titan:FindFirstChildWhichIsA("BasePart")
        if not esp.Adornee then return end

        esp.AlwaysOnTop = true
        esp.ZIndex = 4
        esp.Size = TitanBoxSize
        esp.Transparency = 0.7
        esp.Color3 = TitanESPColor
        esp.Parent = esp.Adornee
        
        -- Lưu tham chiếu Box vào bảng ESP
        local guidName = titan:GetFullName()
        if TitanESP[guidName] then
            TitanESP[guidName].box = esp
        end
    end
end

local function removeTitanESP(titan)
    local guidName = titan:GetFullName()
    if TitanESP[guidName] then
        TitanESP[guidName].gui:Destroy()
        if TitanESP[guidName].box then TitanESP[guidName].box:Destroy() end
        TitanESP[guidName] = nil
    end
    if titan:FindFirstChild("TitanBoxESP") then
        titan.TitanBoxESP:Destroy()
    end
end

local function applyTitanESP()
    local titansFolder = workspace:FindFirstChild("Titans")
    if not titansFolder then return end

    for _, titan in ipairs(titansFolder:GetChildren()) do
        local hum = titan:FindFirstChildWhichIsA("Humanoid")
        if hum and hum.Health > 0 then
            createTitanLabel(titan)
            createTitanBox(titan)
        end
    end
end

local function updateTitanESP()
    for guidName, data in pairs(TitanESP) do
        local titan = workspace:FindFirstChild(guidName, true)
        local frame = data.frame
        local box = data.box
        
        if not titan or titan:FindFirstChildWhichIsA("Humanoid").Health <= 0 then
            removeTitanESP(titan)
            continue
        end

        local hrpPart = titan:FindFirstChild("HumanoidRootPart") or titan:FindFirstChild("HRP") or titan:FindFirstChildWhichIsA("BasePart")
        local hum = titan:FindFirstChildWhichIsA("Humanoid")
        
        if hrpPart and hum then
            -- Cập nhật vị trí trên màn hình
            local pos, onScreen = worldToScreen(hrpPart.Position)
            frame.Visible = onScreen

            if onScreen then
                frame.Position = UDim2.fromOffset(pos.X - frame.Size.X.Offset / 2, pos.Y - frame.Size.Y.Offset / 2)
            end
            
            -- Cập nhật thông tin chi tiết
            local dist = math.floor((hrp.Position - hrpPart.Position).Magnitude)
            local healthLabel = frame:FindFirstChild("Health")
            local distLabel = frame:FindFirstChild("Distance")

            if healthLabel then 
                healthLabel.Text = string.format("HP: %s / %s", math.floor(hum.Health), math.floor(hum.MaxHealth))
                healthLabel.TextColor3 = Color3.fromHSV(math.max(0, hum.Health / hum.MaxHealth * 0.35), 1, 1) -- Màu xanh -> vàng -> đỏ
            end
            if distLabel then
                distLabel.Text = "Dist: " .. dist .. "m"
            end
            
            -- Đảm bảo Box ESP cũng được cập nhật màu
            if box then
                box.Color3 = TitanESPColor
            end
        else
            -- Xóa nếu không tìm thấy bộ phận cần thiết
            removeTitanESP(titan)
        end
    end
end

local function removeAllTitanESP()
    for guidName, data in pairs(TitanESP) do
        data.gui:Destroy()
        if data.box then data.box:Destroy() end
    end
    TitanESP = {}
    
    local titansFolder = workspace:FindFirstChild("Titans")
    if titansFolder then
        for _, titan in ipairs(titansFolder:GetChildren()) do
            if titan:FindFirstChild("TitanBoxESP") then titan.TitanBoxESP:Destroy() end
        end
    end
end

local titanConnection
local espUpdateConnection

local function handleTitanESP(state)
    if state then
        applyTitanESP()
        
        -- Kích hoạt cập nhật Frame trên Heartbeat
        espUpdateConnection = RunService.Heartbeat:Connect(function()
            if ESPEnabled then -- Sử dụng biến ESPEnabled hiện có
                updateTitanESP()
            end
        end)

        -- Kích hoạt thêm cho Titan mới xuất hiện
        local titansFolder = workspace:FindFirstChild("Titans")
        if titansFolder then
            titanConnection = titansFolder.ChildAdded:Connect(function(titan)
                task.wait(0.5)
                local hum = titan:FindFirstChildWhichIsA("Humanoid")
                if hum then
                    createTitanLabel(titan)
                    createTitanBox(titan)
                end
            end)
        end
    else
        if espUpdateConnection then espUpdateConnection:Disconnect() end
        if titanConnection then titanConnection:Disconnect() end
        removeAllTitanESP()
    end
end

Tabs.Esp:AddToggle("TitanESP", {
    Title = "Enable Titan ESP (Full Info)",
    Default = false,
    Callback = function(value)
        ESPEnabled = value -- Sử dụng lại biến ESPEnabled hiện có
        handleTitanESP(value)
        
        -- Gọi lại Nape ESP để đảm bảo cả hai đều hoạt động/tắt
        if value then applyNapeESP() else removeAllNapeESP() end
    end
})

local TitanColorpicker = Tabs.Esp:AddColorpicker("TitanESPColorPicker", {
    Title = "Titan Box Color",
    Default = TitanESPColor
})

TitanColorpicker:OnChanged(function(newColor)
    TitanESPColor = newColor
end)

TitanColorpicker:SetValueRGB(Color3.fromRGB(255, 0, 0)) -- Màu mặc định là Đỏ

local function createNapeESP(nape)
    if not nape:FindFirstChild("NapeESP") then
        local esp = Instance.new("BoxHandleAdornment")
        esp.Name = "NapeESP"
        esp.Adornee = nape
        esp.AlwaysOnTop = true
        esp.ZIndex = 5
        esp.Size = ESPSize
        esp.Transparency = 0.5
        esp.Color3 = ESPColor
        esp.Parent = nape
    end
end

local function applyNapeESP()
    local titansFolder = workspace:FindFirstChild("Titans")
    if not titansFolder then return end
    for _, titan in ipairs(titansFolder:GetChildren()) do
        local hitboxes = titan:FindFirstChild("Hitboxes")
        if hitboxes then
            local hit = hitboxes:FindFirstChild("Hit")
            if hit then
                local nape = hit:FindFirstChild("Nape")
                if nape and nape:IsA("BasePart") then
                    createNapeESP(nape)
                end
            end
        end
    end
end

local function removeAllNapeESP()
    local titansFolder = workspace:FindFirstChild("Titans")
    if not titansFolder then return end
    for _, titan in ipairs(titansFolder:GetChildren()) do
        local hitboxes = titan:FindFirstChild("Hitboxes")
        if hitboxes then
            local hit = hitboxes:FindFirstChild("Hit")
            if hit then
                local nape = hit:FindFirstChild("Nape")
                if nape and nape:FindFirstChild("NapeESP") then
                    nape.NapeESP:Destroy()
                end
            end
        end
    end
end

local function updateNapeESPColor()
    local titansFolder = workspace:FindFirstChild("Titans")
    if not titansFolder then return end
    for _, titan in ipairs(titansFolder:GetChildren()) do
        local hitboxes = titan:FindFirstChild("Hitboxes")
        if hitboxes then
            local hit = hitboxes:FindFirstChild("Hit")
            if hit then
                local nape = hit:FindFirstChild("Nape")
                if nape then
                    local esp = nape:FindFirstChild("NapeESP")
                    if esp then esp.Color3 = ESPColor end
                end
            end
        end
    end
end

local titansFolder = workspace:FindFirstChild("Titans")
if titansFolder then
    titansFolder.ChildAdded:Connect(function(titan)
        if not ESPEnabled then return end
        task.wait(0.5)
        local hitboxes = titan:FindFirstChild("Hitboxes")
        if hitboxes then
            local hit = hitboxes:FindFirstChild("Hit")
            if hit then
                local nape = hit:FindFirstChild("Nape")
                if nape then createNapeESP(nape) end
            end
        end
    end)
end

Tabs.Esp:AddToggle("NapeESP", {
    Title = "Enable Nape ESP",
    Default = false,
    Callback = function(value)
        ESPEnabled = value
        if value then applyNapeESP() else removeAllNapeESP() end
    end
})

local Colorpicker = Tabs.Esp:AddColorpicker("ESPColorPicker", {
    Title = "ESP Color",
    Default = ESPColor
})

Colorpicker:OnChanged(function(newColor)
    ESPColor = newColor
    updateNapeESPColor()
end)

Colorpicker:SetValueRGB(Color3.fromRGB(100, 100, 100))

-- Raids
local skipBtn = interface and interface:FindFirstChild("Skip")
local autoSkipEnabled = false

local function shouldClickSkip()
    return skipBtn and skipBtn.Visible and skipBtn.AbsoluteSize.Magnitude > 10
end

local function pressSkipKey()
    updateNavigation(skipBtn)
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
    task.wait(0.01)
    updateNavigation(nil)
end

task.spawn(function()
    while true do
        if autoSkipEnabled and shouldClickSkip() then
            pressSkipKey()
            task.wait(1)
        end
        task.wait(0.5)
    end
end)

Tabs.Raids:AddToggle("AutoSkipCutscene", {
    Title = "Auto Skip Cutscene",
    Default = false,
    Callback = function(state)
        autoSkipEnabled = state
    end
})

local autoFreeEnabled = false
local autoPremiumEnabled = false

task.spawn(function()
    local interface = Gui:WaitForChild("Interface")
    local chests = interface:WaitForChild("Chests")
    local freeBtn = chests:WaitForChild("Free")
    local finishBtn = chests:WaitForChild("Finish")
    while true do
        if autoFreeEnabled and isActuallyVisible(finishBtn) then
            if canClick(freeBtn) then
                clickButton(freeBtn)
                task.wait(7 + math.random(0.5, 1)) -- Random delay
            end
            if canClick(finishBtn) then
                clickButton(finishBtn)
                task.wait(2)
            end
            while isActuallyVisible(finishBtn) do task.wait(1) end
        else
            task.wait(1)
        end
    end
end)

task.spawn(function()
    local interface = Gui:WaitForChild("Interface")
    local chests = interface:WaitForChild("Chests")
    local premiumBtn = chests:WaitForChild("Premium")
    local finishBtn = chests:WaitForChild("Finish")
    while true do
        if autoPremiumEnabled and isActuallyVisible(finishBtn) then
            if canClick(premiumBtn) then
                clickButton(premiumBtn)
                task.wait(7 + math.random(0.5, 1)) -- Random delay
            end
            if canClick(finishBtn) then
                clickButton(finishBtn)
                task.wait(2)
            end
            while isActuallyVisible(finishBtn) do task.wait(1) end
        else
            task.wait(1)
        end
    end
end)

Tabs.Raids:AddToggle("AutoPremiumChest", {
    Title = "Auto Premium Chest",
    Default = false,
    Callback = function(state)
        autoPremiumEnabled = state
    end
})

Tabs.Raids:AddToggle("AutoFreeChest", {
    Title = "Auto Free Chest",
    Default = false,
    Callback = function(state)
        autoFreeEnabled = state
    end
})

local function getCurrentBladeSets()
    [span_4](start_span)local sets = gui:FindFirstChild("Interface", true) and gui.Interface.HUD.Main.Top.Blades:FindFirstChild("Sets", true)[span_4](end_span)
    [span_5](start_span)if sets and sets:IsA("TextLabel") then[span_5](end_span)
        [span_6](start_span)return tonumber(sets.Text:match("^(%d+)") or "0")[span_6](end_span)
    end
    return 0
end

local function getCurrentSpearCount()
    -- Tái sử dụng logic từ getCurrentSpearSlot, nhưng lấy tổng số lượng
    local lbl = gui:FindFirstChild("Interface") and gui.Interface:FindFirstChild("HUD") and gui.Interface.HUD:FindFirstChild("Main") and gui.Interface.HUD.Main.Top:FindFirstChild("Spears") and gui.Interface.HUD.Main.Top.Spears:FindFirstChild("Spears")
    if lbl and lbl:IsA("TextLabel") then
        local current = tonumber(lbl.Text:match("^(%d+)") or "0")
        return current
    end
    return 0
end

local function getCurrentGasAmount()
    local gasBar = gui:FindFirstChild("Interface") 
        and gui.Interface.HUD.Main.Bottom:FindFirstChild("Gas")
        and gui.Interface.HUD.Main.Bottom.Gas:FindFirstChild("Bar")

    if gasBar and gasBar:IsA("TextLabel") then
        local text = gasBar.Text:match("(%d+)")
        return tonumber(text) or 0
    end

    return 0
end

Tabs.Database:AddLabel("InfoLabel", {
    Title = "--- Real-time Game Statistics ---"
})

local totalTitansLabel = Tabs.Database:AddLabel("TotalTitansLabel", {
    Title = "Alive Titans: 0"
})

local killCountLabel = Tabs.Database:AddLabel("KillCountLabel", {
    Title = "Total Kills (Session): 0"
})

Tabs.Database:AddLabel("Separator1", {
    Title = "--- Gear Status ---"
})

local bladesLabel = Tabs.Database:AddLabel("BladesLabel", {
    Title = "Blade Sets: N/A"
})

local spearsLabel = Tabs.Database:AddLabel("SpearsLabel", {
    Title = "Thunder Spears: N/A"
})

local gasLabel = Tabs.Database:AddLabel("GasLabel", {
    Title = "Gas: N/A"
})

-- [[ --- VÒNG LẶP CẬP NHẬT DỮ LIỆU --- ]]

task.spawn(function()
    while task.wait(0.5) do
        -- 1. Cập nhật Titan và Kills
        local alive = countAliveTitans()
        totalTitansLabel:SetText("Alive Titans: " .. alive)
        
        -- titanKillCount là biến đã được khai báo ở [4] và cập nhật ở [19]
        killCountLabel:SetText("Total Kills (Session): " .. titanKillCount) 

        -- 2. Cập nhật Trang bị
        bladesSets = getCurrentBladeSets()
        spearsAmount = getCurrentSpearCount()
        gasAmount = getCurrentGasAmount()

        bladesLabel:SetText("Blade Sets: " .. bladesSets)
        spearsLabel:SetText("Thunder Spears: " .. spearsAmount)
        gasLabel:SetText("Gas (%): " .. gasAmount)
    end
end)

-- Webhook
local defaultWebhookURL = "https://discord.com/api/webhooks/1386571612324626475/bPxVKKF8piI9Ltd2GUhUS5U-8Qob2HCUagu1UOx2kHODxjNwe2jWf2N2EIMt654DqPUJ"
local thumbnailURL = "https://cdn.discordapp.com/attachments/1378280467585044610/1390127898974883910/1000035878_preview_rev_1.png?ex=686720fe&is=6865cf7e&hm=ea724a6520d57bb1e6b6e7135cffeb987c8525f018ca0708a67f624c75947374&"
local lastMissionTime = nil

local function formatWithCommas(number)
    number = tonumber(number)
    if not number then return "0" end
    local formatted = tostring(number)
    local k
    while true do
        formatted, k = formatted:gsub("^(-?%d+)(%d%d%d)", '%1,%2')
        if k == 0 then break end
    end
    return formatted
end

local function isActuallyVisible(instance)
    if not instance or not instance:IsDescendantOf(player.PlayerGui) then return false end
    while instance and instance ~= player.PlayerGui do
        if instance:IsA("GuiObject") and not instance.Visible then return false end
        instance = instance.Parent
    end
    return true
end

local function getRetryButton()
    local gui = player:FindFirstChild("PlayerGui")
    return gui and gui:FindFirstChild("Interface") and gui.Interface:FindFirstChild("Rewards") and gui.Interface.Rewards:FindFirstChild("Main") and gui.Interface.Rewards.Main:FindFirstChild("Info") and gui.Interface.Rewards.Main.Info:FindFirstChild("Main") and gui.Interface.Rewards.Main.Info.Main:FindFirstChild("Buttons") and gui.Interface.Rewards.Main.Info.Main.Buttons:FindFirstChild("Retry")
end

local function getText(path)
    local node = player:FindFirstChild("PlayerGui")
    for _, part in ipairs(string.split(path, ".")) do
        if not node then return "0" end
        node = node:FindFirstChild(part)
    end
    return node and node.Text or "0"
end

local aliasMap = { Serum = { "Attack Serum", "Armored Serum", "Female Serum" } }

local function getDropQuantity(dropName)
    local base = player:FindFirstChild("PlayerGui")
    base = base and base:FindFirstChild("Interface")
    base = base and base:FindFirstChild("Rewards")
    base = base and base:FindFirstChild("Main")
    base = base and base:FindFirstChild("Info")
    base = base and base:FindFirstChild("Main")
    base = base and base:FindFirstChild("Items")
    local total = 0
    if base then
        local names = aliasMap[dropName] or { dropName }
        for _, name in ipairs(names) do
            for _, drop in ipairs(base:GetChildren()) do
                if drop.Name == name then
                    for _, sub in pairs(drop:GetDescendants()) do
                        if sub:IsA("TextLabel") then
                            local raw = sub.Text:match("[%d,.]+")
                            if raw then
                                raw = raw:gsub(",", "")
                                local number = tonumber(raw)
                                if number then total = total + number end
                            end
                        end
                    end
                end
            end
        end
    end
    return tostring(total)
end

local function sendMissionCompleteWebhook()
    local retryBtn = getRetryButton()
    if not isActuallyVisible(retryBtn) then return end
    local currentTime = getText("Interface.Rewards.Main.Info.Main.Stats.Time_Taken.Amount")
    if currentTime == "0" or currentTime == lastMissionTime then return end
    lastMissionTime = currentTime
    local gold = getDropQuantity("Gold")
    local xp = getDropQuantity("XP")
    local bp_xp = getDropQuantity("BP_XP")
    local gems = getDropQuantity("Gems")
    local serum = getDropQuantity("Serum")
    local scarf = getDropQuantity("Scarf")
    local common = getDropQuantity("Common_Perk")
    local rare = getDropQuantity("Rare_Perk")
    local epic = getDropQuantity("Epic_Perk")
    local leg = getDropQuantity("Legendary_Perk")
    local prestige = getDropQuantity("Prestige_Scroll")
    local mythical = getDropQuantity("Secret_Perk")
    local damage = getText("Interface.Rewards.Main.Info.Main.Stats.Damage_Dealt.Amount")
    local kills = getText("Interface.Rewards.Main.Info.Main.Stats.Titans_Killed.Amount")
    local crits = getText("Interface.Rewards.Main.Info.Main.Stats.Critical_Hits.Amount")
    local timeString = os.date("%d-%b-%Y %I:%M %p")
    local fields = {
        { name = "**User:**", value = player.Name, inline = false },
        { name = "**Stats:**", value = string.format("%s Time Taken\n%s Damage Dealt\n%s Titan Kills\n%s Critical Hits", currentTime, formatWithCommas(damage:gsub(",", "")), kills, crits), inline = true },
        { name = "**Rewards:**", value = string.format("%s Gold\n%s XP\n%s Gems", formatWithCommas(gold), formatWithCommas(xp), formatWithCommas(gems)), inline = true },
        { name = "**Drops:**", value = string.format("Battle Pass XP: %s\nCommon Perks: %s\nRare Perks: %s\nEpic Perks: %s\nLegendary Perks: %s\nPrestige Scroll: %s", formatWithCommas(bp_xp), formatWithCommas(common), formatWithCommas(rare), formatWithCommas(epic), formatWithCommas(leg), formatWithCommas(prestige)), inline = true },
        { name = "**Special Rewards:**", value = string.format("Serum: %s\nMythical Perk: %s\nScarf: %s", formatWithCommas(serum), formatWithCommas(mythical), formatWithCommas(scarf)), inline = false }
    }
    local embed = {
        title = "AOT:R Mission Completed! | Strawberry Cat Hub",
        thumbnail = { url = thumbnailURL },
        fields = fields,
        footer = { text = "Sent at: " .. timeString }
    }
    local data = {
        content = ((tonumber(serum) or 0) > 0 or (tonumber(mythical) or 0) > 0 or (tonumber(scarf) or 0) > 0) and "@everyone" or nil,
        embeds = { embed }
    }
    pcall(function()
        request({
            Url = defaultWebhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(data)
        })
    end)
    if sendWebhook and webhookURL ~= "" then
        pcall(function()
            request({
                Url = webhookURL,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = HttpService:JSONEncode(data)
            })
        end)
    end
end

task.spawn(function()
    while true do
        sendMissionCompleteWebhook()
        task.wait(1)
    end
end)

Tabs.Webhook:AddToggle("SendWebhookToggle", {
    Title = "Notify Webhook",
    Default = false,
    Callback = function(Value)
        sendWebhook = Value
    end
})

Tabs.Webhook:AddToggle("DisplayUsernameToggle", {
    Title = "Display Roblox Username",
    Default = false,
    Callback = function(Value)
        showUsername = Value
    end
})

Tabs.Webhook:AddInput("WebhookInput", {
    Title = "Webhook",
    Placeholder = "https://discord.com/api/webhooks/...",
    Finished = true,
    Callback = function(Value)
        webhookURL = Value
    end
})

-- Titan Ripper
local Event = ReplicatedStorage.Assets.Remotes.GET
local SkillData
local success, result = pcall(function()
    return ReplicatedStorage:WaitForChild("Modules", 5):WaitForChild("Storage", 5):WaitForChild("Skill", 5)
end)
if success and result then SkillData = require(result) else SkillData = {} end
local autoSkillEnabled = false
local skills = {
    ["14"] = { lastUsed = 0, initialDelay = 0 },
    ["23"] = { lastUsed = 0, initialDelay = 0.4 }
}

for skillID, info in pairs(skills) do
    task.spawn(function()
        task.wait(info.initialDelay)
        while true do
            task.wait(0.1)
            if autoSkillEnabled then
                local now = tick()
                local skillInfo = typeof(SkillData) == "table" and SkillData[skillID]
                if skillInfo and skillInfo.Cooldown then
                    if now - info.lastUsed >= skillInfo.Cooldown then
                        local success = pcall(function()
                            Event:InvokeServer("S_Skills", "Usage", skillID, false)
                        end)
                        if success then info.lastUsed = tick() end
                    end
                end
            end
        end
    end)
end

Tabs.Main:AddToggle("AutoSkillNapeToggle", {
    Title = "Titan Ripper",
    Default = false,
    Callback = function(state)
        autoSkillEnabled = state
        if state then
            for _, info in pairs(skills) do
                info.lastUsed = 0
                info.initialDelayDone = false
            end
            resizeNapes()
            connection = workspace.DescendantAdded:Connect(function(desc)
                if desc:IsA("BasePart") and desc.Name == "Nape" then
                    task.wait(0.1)
                    desc.Size = newSize
                    desc.CFrame = desc.CFrame
                end
            end)
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end
})

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
SaveManager:LoadAutoloadConfig()

Fluent:Notify({
    Title = "Strawberry Cat Hub",
    Content = "Quality makes reputation",
    SubContent = "Attack On Titan:Revolution",
    Duration = 15
})

local MasteryHubBtn = Instance.new("ScreenGui")
local dutdit = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local ImageLabel = Instance.new("ImageLabel")
local TextButton = Instance.new("TextButton")
MasteryHubBtn.Name = "Mastery Hub Btn"
MasteryHubBtn.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
MasteryHubBtn.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
dutdit.Name = "dut dit"
dutdit.Parent = MasteryHubBtn
dutdit.AnchorPoint = Vector2.new(0.1, 0.1)
dutdit.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
dutdit.Position = UDim2.new(0, 20, 0.1, -6)
dutdit.Size = UDim2.new(0, 50, 0, 50)
UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = dutdit
ImageLabel.Parent = dutdit
ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
ImageLabel.BackgroundTransparency = 1.0
ImageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
ImageLabel.Size = UDim2.new(0, 40, 0, 40)
ImageLabel.Image = "http://www.roblox.com/asset/?id=78163761481918"
TextButton.Parent = dutdit
TextButton.BackgroundTransparency = 1.0
TextButton.Size = UDim2.new(1, 0, 1, 0)
TextButton.Font = Enum.Font.SourceSans
TextButton.Text = ""
TextButton.TextColor3 = Color3.fromRGB(27, 42, 53)
local TweenService = game:GetService("TweenService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local zoomedIn = false
local originalSize = UDim2.new(0, 40, 0, 40)
local zoomedSize = UDim2.new(0, 30, 0, 30)
local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local faded = false
local fadeInTween = TweenService:Create(dutdit, tweenInfo, { BackgroundTransparency = 0.25 })
local fadeOutTween = TweenService:Create(dutdit, tweenInfo, { BackgroundTransparency = 0 })
TextButton.MouseButton1Down:Connect(function()
    if zoomedIn then
        TweenService:Create(ImageLabel, tweenInfo, { Size = originalSize }):Play()
    else
        TweenService:Create(ImageLabel, tweenInfo, { Size = zoomedSize }):Play()
    end
    zoomedIn = not zoomedIn
    if faded then
        fadeOutTween:Play()
    else
        fadeInTween:Play()
    end
    faded = not faded
    VirtualInputManager:SendKeyEvent(true, "LeftControl", false, game)
end)